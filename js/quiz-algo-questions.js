let questions = [
    {
    numb: 1,
    question: "What is recurrence for worst case of QuickSort and what is the time complexity in Worst case?",
    answer: "Recurrence is T(n) = T(n-1) + O(n) and time complexity is O(n^2)",
    options: [
      "	Recurrence is T(n) = T(n-2) + O(n) and time complexity is O(n^2).",
      "Recurrence is T(n) = T(n-1) + O(n) and time complexity is O(n^2)",
      "	Recurrence is T(n) = 2T(n/2) + O(n) and time complexity is O(nLogn)",
      "Recurrence is T(n) = T(n/10) + T(9n/10) + O(n) and time complexity is O(nLogn)",
    ]
  },
    {
    numb: 2,
    question: "Which of the following algorithms is NOT a divide & conquer algorithm by nature?",
    answer: "Heap Sort",
    options: [
      "Heap Sort",
      "Cooley-Tukey fast Fourier transform",
      "Euclidean algorithm to compute the greatest common divisor",
      "Quick Sort"
    ]
  },
    {
    numb: 3,
    question: "Consider the polynomial p(x) = a0 + a1x + a2x^2 +a3x^3, where ai != 0, for all i. The minimum number of multiplications needed to evaluate p on an input x is:",
    answer: "3",
    options: [
        "3",
        "4",
        "8",
        "9"
    ]
  },
    {
    numb: 4,
    question: "Which of the following standard algorithms is not Dynamic Programming based?",
    answer: "Prim's Minimum Spanning Tree",
    options: [
      "Bellmanâ€“Ford Algorithm for single source shortest path",
      "Floyd Warshall Algorithm for all pairs shortest paths",
      "Prim's Minimum Spanning Tree",
      "0-1 Knapsack problem"
    ]
  },
    {
    numb: 5,
    question: "We use dynamic programming approach when",
    answer: "The solution has optimal substructure",
    options: [
      "We need an optimal solution",
      "The solution has optimal substructure",
      "The given problem can be reduced to the 3-SAT problem",
      "It's faster than Greedy"
    ]
  },
 
];